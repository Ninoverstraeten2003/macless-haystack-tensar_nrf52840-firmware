#include "ble_gap.h"
#include "boards.h"
#include "nrf_delay.h"
#include "ble_stack.h"
#include "nrf_error.h"
#include "app_error.h"
#include "openhaystack.h"
#include "battery.h"
#include "nrf_sdh.h"
#include "nrf_soc.h"
#include "public_key.h"  /* auto-generated by binary.py via `make generate_key` */

/*──────────────────────────────────────────────────────────────
 * CONFIGURATION
 *──────────────────────────────────────────────────────────────*/
#define DEBUG_LEDS_ENABLED   0
#define ADV_INTERVAL_MS      2000
#define TX_POWER_DBM         0

/* Battery update interval via wakeup counting.
 *
 * With 2000 ms advertising interval, the SoftDevice wakes
 * the CPU roughly once per advertising event:
 *
 *   Wakes/hour ≈ 3600 / 2 = 1800
 *   Wakes/day  ≈ 43200
 *   Wakes/week ≈ 302400
 *
 * This is approximate — the CPU may wake slightly more or
 * less often — but for battery level reporting, ±hours
 * of drift over a week is perfectly fine.                    */
#define WAKES_PER_BATTERY_UPDATE  302400UL  /* ≈ 7 days */


/*──────────────────────────────────────────────────────────────
 * Error handler
 *──────────────────────────────────────────────────────────────*/
void app_error_fault_handler(uint32_t id, uint32_t pc, uint32_t info)
{
#if DEBUG_LEDS_ENABLED
    uint32_t err_code = id;
    if (id == NRF_FAULT_ID_SDK_ERROR) {
        err_code = ((error_info_t *)info)->err_code;
    }
    bsp_board_init(BSP_INIT_LEDS);
    while (1) {
        bsp_board_led_off(0); nrf_delay_ms(1500);
        bsp_board_led_on(0);  nrf_delay_ms(1000);
        for (uint32_t i = 0; i < err_code && i < 20; i++) {
            bsp_board_led_off(0); nrf_delay_ms(200);
            bsp_board_led_on(0);  nrf_delay_ms(200);
        }
        nrf_delay_ms(3000);
    }
#else
    (void)id; (void)pc; (void)info;
    NVIC_SystemReset();
#endif
}

/*──────────────────────────────────────────────────────────────
 * Debug LED helpers
 *──────────────────────────────────────────────────────────────*/
#if DEBUG_LEDS_ENABLED
static void debug_pulse(uint8_t count, uint16_t on_ms, uint16_t off_ms, uint16_t tail_ms)
{
    for (uint8_t i = 0; i < count; i++) {
        bsp_board_led_off(0); nrf_delay_ms(on_ms);
        bsp_board_led_on(0);  nrf_delay_ms(off_ms);
    }
    if (tail_ms) nrf_delay_ms(tail_ms);
}
#define DEBUG_INIT_LEDS()     bsp_board_init(BSP_INIT_LEDS)
#define DEBUG_BREADCRUMB(n)   debug_pulse((n), 100, 100, 400)
#define DEBUG_LEDS_OFF()      bsp_board_led_on(0)
#else
#define DEBUG_INIT_LEDS()     ((void)0)
#define DEBUG_BREADCRUMB(n)   ((void)0)
#define DEBUG_LEDS_OFF()      ((void)0)
#endif

/*──────────────────────────────────────────────────────────────
 * Disconnect unused GPIOs
 *──────────────────────────────────────────────────────────────*/
static void configure_unused_pins(void)
{
    static const uint8_t unused_p0[] = {
        2, 3, 4, 5, 6, 7, 8, 9, 10,
        11, 12, 13, 14, 20, 22, 24, 26, 29, 31
    };
    static const uint8_t unused_p1[] = { 0, 1, 2, 4, 6 };

    for (uint32_t i = 0; i < sizeof(unused_p0); i++) {
        NRF_P0->PIN_CNF[unused_p0[i]] =
            (GPIO_PIN_CNF_INPUT_Disconnect << GPIO_PIN_CNF_INPUT_Pos);
    }
    for (uint32_t i = 0; i < sizeof(unused_p1); i++) {
        NRF_P1->PIN_CNF[unused_p1[i]] =
            (GPIO_PIN_CNF_INPUT_Disconnect << GPIO_PIN_CNF_INPUT_Pos);
    }
}

/*──────────────────────────────────────────────────────────────
 * Main
 *──────────────────────────────────────────────────────────────*/
int main(void)
{
    DEBUG_INIT_LEDS();
    DEBUG_BREADCRUMB(1);

    configure_unused_pins();

    init_ble();
    DEBUG_BREADCRUMB(2);

    uint8_t *bleAddr;
    uint8_t *advData;
    uint8_t dataLen = setAdvertisementKey(OFFLINE_FINDING_PUBLIC_KEY,
                                          &bleAddr, &advData);

    setMacAddress(bleAddr);
    updateBatteryLevel(advData);
    setAdvertisementData(advData, dataLen);
    DEBUG_BREADCRUMB(3);

    DEBUG_LEDS_OFF();

    startAdvertisement(ADV_INTERVAL_MS, TX_POWER_DBM);

    /* Ultra-low-power main loop.
     * Count wakeups to schedule periodic battery updates.
     * No extra peripherals, no extra RAM, no extra current. */
    uint32_t wake_count = 0;

    while (1) {
        sd_app_evt_wait();

        if (++wake_count >= WAKES_PER_BATTERY_UPDATE) {
            wake_count = 0;

            updateBatteryLevel(advData);
            stopAdvertisement();
            setAdvertisementData(advData, dataLen);
            startAdvertisement(ADV_INTERVAL_MS, TX_POWER_DBM);
        }
    }
}